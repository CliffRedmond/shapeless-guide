## Case study: case class migrations

We'll finish this chapter with a more useful example:
a type class for performing "migrations"
(aka "evolutions") on case classes[^database-migrations].
For example, suppose version 1 of our app has a case class:

[^database-migrations]: The term "migration" is stolen from
"database migration"---an SQL script that
automates an upgrade to a database schema
to keep it in line with a change in a corresponding application.

```tut:book:silent
case class IceCreamV1(name: String, numCherries: Int, inCone: Boolean)
```

our type class will let us perform certain
mechanical "upgrades" for free:

```tut:book:silent
// Remove fields:
case class IceCreamV2a(name: String, inCone: Boolean)

// Reorder fields:
case class IceCreamV2b(name: String, inCone: Boolean, numCherries: Int)

// Add fields (provided we can determine a default value):
case class IceCreamV2c(
  name: String, inCone: Boolean, numCherries: Int, numWaffles: Int)
```

Ideally we'd like to be able to write code like this:

```scala
IceCreamV1("Sundae", 1, false).migrateTo[IceCreamV2a]
```

The type class should take care of the migration
without additional boilerplate.

### The type class

The `Migration` type class represents
a transformation from a source to a destination type.
Both of these are going to be "input" types in our derivation,
so we model both as type parameters.
We don't need an `Aux` type alias
because there are no type members to expose as parameters:

```tut:book:silent
trait Migration[A, B] {
  def apply(a: A): B
}
```

We'll introduce syntax for `Migration` now
to make later examples more readable:

```tut:book:silent
implicit class MigrationOps[A](a: A) {
  def migrateTo[B](implicit migration: Migration[A, B]): B =
    migration.apply(a)
}
```

### Step 1. Removing fields

Let's build up the solution piece by piece,
starting with field removal.
We can do this in several steps:

 1. convert `A` to its generic representation;
 2. filter the `HList` from step 1---only retain
    fields that are also in `B`;
 3. convert the output of step 2 to `B`.

We can implement steps 1 and 3 with `Generic` or `LabelledGeneric`,
and step 2 with an existing op called `Intersection`:

```tut:book:silent
import shapeless._
import shapeless.ops.hlist

implicit def genericMigration[A, B, ARepr <: HList, BRepr <: HList](
  implicit
  aGen    : LabelledGeneric.Aux[A, ARepr],
  bGen    : LabelledGeneric.Aux[B, BRepr],
  inter   : hlist.Intersection.Aux[ARepr, BRepr, BRepr]
): Migration[A, B] = new Migration[A, B] {
  def apply(a: A): B =
    bGen.from(inter.apply(aGen.to(a)))
}
```

The `Intersection.Aux` type takes three type parameters:
two input `HLists` and one output for the intersection type.
In the example above we are specifying
`ARepr` and `BRepr` as the input types
and `BRepr` as the output type.
This means type class resolution will only work
if `B` has an exact subset of the fields of `A`,
specified with the exact same names in the same order:

```tut:book
IceCreamV1("Sundae", 1, true).migrateTo[IceCreamV2a]
```

If we try to use `Migration` with non-conforming types,
implicit resolution will fail:

```tut:book:fail
IceCreamV1("Sundae", 1, true).migrateTo[IceCreamV2b]
```

<div class="callout callout-info">
*Field uniqueness*

What would have happened if we had used `Generic` above
instead of `LabelledGeneric`?
Both type classes return `HLists`---the only difference
is that `LabelledGeneric` refines the types of the members
with the singleton types of their identifiers.

We're not using field names directly in this example,
but they are having an effect on the way other type classes work.
`Intersection`, for example, calculates a list of common elements
based on their types.
The types generated by `LabelledGeneric` are different
if the field names are different,
so `Intersection` is taking the names into account.
If we had used regular `Generic`,
the behaviour would be different.
</div>

### Step 2. Reordering fields

To add support for field reordering
we need to lean on another ops type class.
The `Align` type class allows us reorder the fields in an `HList`
so they are in the same order as another `HList`.
We can use `Align` to redefine our instance as follows:

```tut:book:silent
implicit def genericMigration[
  A, B,
  ARepr <: HList, BRepr <: HList,
  Unaligned <: HList
](
  implicit
  aGen    : LabelledGeneric.Aux[A, ARepr],
  bGen    : LabelledGeneric.Aux[B, BRepr],
  inter   : hlist.Intersection.Aux[ARepr, BRepr, Unaligned],
  align   : hlist.Align[Unaligned, BRepr]
): Migration[A, B] = new Migration[A, B] {
  def apply(a: A): B =
    bGen.from(align.apply(inter.apply(aGen.to(a))))
}
```

We introduce a new type parameter called `Unaligned`
to represent the intersection of `ARepr` and `BRepr`
before alignment,
and use `Align` to convert `Unaligned` to `BRepr`.
Note that, like `Migration`, `Align` doesn't have any
type members and doesn't require an `Aux` type alias.

With this modified type class instance
we can support the removal and reordering of fields:

```tut:book
IceCreamV1("Sundae", 1, true).migrateTo[IceCreamV2a]
IceCreamV1("Sundae", 1, true).migrateTo[IceCreamV2b]
```

However, we still get a failure if we try to add fields:

```tut:book:fail
IceCreamV1("Sundae", 1, true).migrateTo[IceCreamV2c]
```

### Step 3. Adding new fields

To allow the user to add new fields during a migration,
we need a mechanism for calculating default values.
Shapeless doesn't provide a type class for this,
so we'll make our own:

```tut:book:silent
trait Empty[A] {
  def get: A
}

def createEmpty[A](body: => A): Empty[A] =
  new Empty[A] {
    def get: A = body
  }
```

We can define instances for `Empty`
using the techniques from Chapter [@sec:labelled-generic].
We need instances for a few core types,
`HNil`, and record `HLists` with tagged head types:

```tut:book:silent
import shapeless.labelled.{field, FieldType}

implicit val emptyInt     : Empty[Int]     = createEmpty(0)
implicit val emptyDouble  : Empty[Double]  = createEmpty(0.0)
implicit val emptyBoolean : Empty[Boolean] = createEmpty(false)
implicit val emptyString  : Empty[String]  = createEmpty("")
implicit val emptyHnil    : Empty[HNil]    = createEmpty(HNil)
implicit def emptyHList[K <: Symbol, H, T <: HList](
  implicit
  hEmpty: Lazy[Empty[H]],
  tEmpty: Empty[T]
): Empty[FieldType[K, H] :: T] =
  createEmpty(field[K](hEmpty.value.get) :: tEmpty.get)
```

We need to combine `Empty` with a couple of other ops type classes
to complete our final implementation of `Migration`.
Here's the full list of steps:

 1. use `LabelledGeneric` to convert `A` to its generic representation;
 2. use `Intersection` to calculate an `HList` of fields common to `A` and `B`;
 3. calculate the type of fields that appear in `B` but not in `A`;
 4. use `Empty` to calculate an empty `HList` of the type from step 3;
 5. append the common fields from step 2 to the new fiewld from step 4;
 6. use `Align` to reorder the fields from step 5 in the same order as `B`;
 7. use `LabelledGeneric` to convert the output of step 6 to `B`.

We've already seen how to implement steps 1, 2, 4, 6, and 7.
We can implement step 3 using an ops type class called `Diff`
that works very similarly to `Intersection`,
and we can implement step 5 using another ops type class called `Prepend`.
Here's the complete solution:

```tut:book:silent
implicit def genericMigration[
  A, B, ARepr <: HList, BRepr <: HList,
  Common <: HList, Added <: HList, Unaligned <: HList
](
  implicit
  aGen    : LabelledGeneric.Aux[A, ARepr],
  bGen    : LabelledGeneric.Aux[B, BRepr],
  inter   : hlist.Intersection.Aux[ARepr, BRepr, Common],
  diff    : hlist.Diff.Aux[BRepr, Common, Added],
  empty   : Empty[Added], // see below
  prepend : hlist.Prepend.Aux[Added, Common, Unaligned],
  align   : hlist.Align[Unaligned, BRepr]
): Migration[A, B] =
  new Migration[A, B] {
    def apply(a: A): B =
      bGen.from(align(prepend(empty.get, inter(aGen.to(a)))))
  }
```

Note that we don't end up using
all the type class parameters at the value level.
We use `Diff` to calculate the `Added` data type,
but we don't actually need it at run time.
Instead we use `Empty` to summon an instance of `Added`.

With this final version of the type class instance in place
we can use `Migration` for all the use cases we set out
at the beginning of the case study:

```tut:book
IceCreamV1("Sundae", 1, true).migrateTo[IceCreamV2a]
IceCreamV1("Sundae", 1, true).migrateTo[IceCreamV2b]
IceCreamV1("Sundae", 1, true).migrateTo[IceCreamV2c]
```

This is a mighty utilty, indeed,
and we generated the entire thing
with a single type class instance
based on the powerful type classes
built in to `shapeless.ops.hlist`.
